/*
SpaceColinizationGrowth spaceColinizationGrowth = new SpaceColinizationGrowth(77, 1, 7, 9, 9, 1, 7);
spaceColinizationGrowth.generateTree();
Vector seed = target.getLocation().toVector();
World world = target.getLocation().getWorld();
for(Segment b: spaceColinizationGrowth.getBranches()){
    double radius = (b.getPosition().getY() < 9)? 1: 0.5;
    for(Block block: new SegmentIterator(world,b.getPosition().add(seed),b.getEnd(1).add(seed), radius)){
        block.setType(Material.OAK_LOG);
    }
}
for(LeafCluster leaves: spaceColinizationGrowth.getLeaves()){
    buildLeaves(world, seed, leaves);
}
*/


*curve functions instead of just straight lines
*calculate distance on plane perpendicular to vector to center point of each block and check if less than radius of segment

Resources:
* https://github.com/supereggbert/proctree.js/ - proctree
* https://www.instructables.com/id/Procedurally-Generated-Trees/
* https://github.com/jarikomppa/proctree

* fib
* saplings
* genome editor
* world populator
* pine trees
* web app

Tree types
- nether
- pine
- end
- underwater tree

Tree specific spawn conditions

* better populator default (min and max 0 and 1)
* better restrictions on % and amounts;

* display enabled/disabled populators differently in /list -- >> <<

-- update --

